using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.FormKeys.Fallout4;
using Mutagen.Bethesda.Plugins;

namespace WastedEncounters;

public class Program
{
    // Define a variable to hold the settings
    private static Lazy<Settings> _settings = null!;
    private static Settings Settings => _settings.Value;

    private static readonly HashSet<FormLink<IEncounterZoneGetter>> EncounterZonesToIgnore = new()
    {
        Fallout4.EncounterZone.NoZoneZone,
        Fallout4.EncounterZone.NoResetZone
    };
    
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance
            .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
            .SetAutogeneratedSettings(
                nickname: "Settings",
                path: "settings.json",
                out _settings)
            .SetTypicalOpen(GameRelease.Fallout4, "YourPatcher.esp")
            .Run(args);
    }

    public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
    {
        // Only patch the game settings if wanted
        if (Settings.PatchBaseDifficulty)
        {
            PatchGameSettingsFloat(state, Settings.NewGameSettings);
        }
        
        Console.WriteLine($"Patching Encounter Zones...");
        foreach (var encounterZoneGetter in
                 state.LoadOrder.PriorityOrder.EncounterZone().WinningOverrides())
        {
            if (encounterZoneGetter.Flags.HasFlag(EncounterZone.Flag.Workshop)) continue;
            if (EncounterZonesToIgnore.Contains(encounterZoneGetter.FormKey.ToLink<IEncounterZoneGetter>())) continue;

            var modified = false;
            var encounterZoneSetter = encounterZoneGetter.DeepCopy();

            if (Settings.MinLevelOne)
            {
                encounterZoneSetter.MinLevel = 1;
                modified |= encounterZoneSetter.MinLevel != encounterZoneGetter.MinLevel;
            }
            else
            {
                // Get the new Min values from settings
                modified |= PatchEncounterZones(state, encounterZoneSetter);
            }

            // Only patch the max level of encounter zones that aren't already uncapped in Vanilla
            // This is for possible "balance" reasons, but if wanted, could be removed
            if (Settings.MaxLevel > 0 && encounterZoneSetter.MaxLevel is not (99 or 0 or -1))
            {
                encounterZoneSetter.MaxLevel = (sbyte)(encounterZoneSetter.MinLevel + Settings.MaxLevel);
            }
            else
            {
                // Uncapped Max level
                // In Vanilla they sometimes use 99 or -1, probably doesn't effectively matter
                encounterZoneSetter.MaxLevel = 0;
            }
            modified |= encounterZoneSetter.MaxLevel != encounterZoneGetter.MaxLevel;
            
            // Remove Match PC Below Minimum Level flag
            // this does what it sounds like, forces the Encounter Zone to use it's minimum level, not the player's
            encounterZoneSetter.Flags &= ~EncounterZone.Flag.MatchPcBelowMinimumLevel;

            // Never Resets and Disable Combat Boundary
            if (Settings.NeverResets)
                encounterZoneSetter.Flags |= EncounterZone.Flag.NeverResets;

            if (Settings.DisableCombatBoundary)
                encounterZoneSetter.Flags |= EncounterZone.Flag.DisableCombatBoundary;

            modified |= encounterZoneSetter.Flags != encounterZoneGetter.Flags;

            if (modified)
                state.PatchMod.EncounterZones.Set(encounterZoneSetter);
        }
    }

    private static bool PatchEncounterZones(IPatcherState<IFallout4Mod, IFallout4ModGetter> state,
        EncounterZone encounterZoneSetter)
    {
        var modified = false;
        foreach (var encounterZoneEntry in Settings.EncounterZonesEntries)
        {
            if (!encounterZoneEntry.EncounterZones.Contains(encounterZoneSetter.FormKey.ToLink<IEncounterZoneGetter>()))
                continue;

            encounterZoneSetter.MinLevel = (sbyte)encounterZoneEntry.NewMinLevel;
            modified = true;
        }

        return modified;
    }
    
    private static void PatchGameSettingsFloat(IPatcherState<IFallout4Mod, IFallout4ModGetter> state,
        Dictionary<string, float> newGameSettings)
    {
        Console.WriteLine("Patching Game Settings...");

        foreach (var gmst in newGameSettings)
        {
            if (state.LinkCache.TryResolve<IGameSettingFloatGetter>(gmst.Key, out var vanillaGameSetting))
            {
                var modified = (IGameSettingFloat)state.PatchMod.GameSettings
                    .GetOrAddAsOverride<GameSetting, IGameSettingGetter>(vanillaGameSetting);
                modified.Data = gmst.Value;
                continue;
            }

            // The GameSetting can't be found in the Master, so create a new one
            // GameSettings are automatically merged into the game as long as the name matches
            var newGameSetting = new GameSettingFloat(state.PatchMod, gmst.Key)
            {
                Data = gmst.Value
            };

            state.PatchMod.GameSettings.Add(newGameSetting);
        }
    }
}
